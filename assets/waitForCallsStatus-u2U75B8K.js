import{C as K,h as Q,j as V,U as X,T as Y,A as D,k as Z,r as tt,B as N,m as R,n as E,o as G,q as et,t as at,L as st,u as nt,v as rt,w as ot,x as P,y as it,z as I,b as B,D as ct,E as ut,F as A,G as U,I as dt,J as lt,K as j,i as ft,M as ht,s as pt,N as wt,O as mt,P as gt,Q as yt}from"./index-Cp0e8ztF.js";function bt({chain:t,currentChainId:a}){if(!t)throw new K;if(a!==t.id)throw new Q({chain:t,currentChainId:a})}function W(t,{docsPath:a,...o}){const i=(()=>{const d=V(t,o);return d instanceof X?t:d})();return new Y(i,{docsPath:a,...o})}const S=new st(128);async function Ct(t,a){var p,b,M,_;const{account:o=t.account,chain:i=t.chain,accessList:d,authorizationList:l,blobs:w,data:c,gas:m,gasPrice:y,maxFeePerBlobGas:s,maxFeePerGas:g,maxPriorityFeePerGas:f,nonce:n,type:u,value:h,...r}=a;if(typeof o>"u")throw new D({docsPath:"/docs/actions/wallet/sendTransaction"});const e=o?R(o):null;try{Z(a);const C=await(async()=>{if(a.to)return a.to;if(a.to!==null&&l&&l.length>0)return await tt({authorization:l[0]}).catch(()=>{throw new N("`to` is required. Could not infer from `authorizationList`.")})})();if((e==null?void 0:e.type)==="json-rpc"||e===null){let v;i!==null&&(v=await E(t,G,"getChainId")({}),bt({currentChainId:v,chain:i}));const x=(M=(b=(p=t.chain)==null?void 0:p.formatters)==null?void 0:b.transactionRequest)==null?void 0:M.format,k=(x||et)({...at(r,{format:x}),accessList:d,authorizationList:l,blobs:w,chainId:v,data:c,from:e==null?void 0:e.address,gas:m,gasPrice:y,maxFeePerBlobGas:s,maxFeePerGas:g,maxPriorityFeePerGas:f,nonce:n,to:C,type:u,value:h}),L=S.get(t.uid),J=L?"wallet_sendTransaction":"eth_sendTransaction";try{return await t.request({method:J,params:[k]},{retryCount:0})}catch(O){if(L===!1)throw O;const T=O;if(T.name==="InvalidInputRpcError"||T.name==="InvalidParamsRpcError"||T.name==="MethodNotFoundRpcError"||T.name==="MethodNotSupportedRpcError")return await t.request({method:"wallet_sendTransaction",params:[k]},{retryCount:0}).then(F=>(S.set(t.uid,!0),F)).catch(F=>{const q=F;throw q.name==="MethodNotFoundRpcError"||q.name==="MethodNotSupportedRpcError"?(S.set(t.uid,!1),T):q});throw T}}if((e==null?void 0:e.type)==="local"){const v=await E(t,nt,"prepareTransactionRequest")({account:e,accessList:d,authorizationList:l,blobs:w,chain:i,data:c,gas:m,gasPrice:y,maxFeePerBlobGas:s,maxFeePerGas:g,maxPriorityFeePerGas:f,nonce:n,nonceManager:e.nonceManager,parameters:[...rt,"sidecars"],type:u,value:h,...r,to:C}),x=(_=i==null?void 0:i.serializers)==null?void 0:_.transaction,z=await e.signTransaction(v,{serializer:x});return await E(t,ot,"sendRawTransaction")({serializedTransaction:z})}throw(e==null?void 0:e.type)==="smart"?new P({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new P({docsPath:"/docs/actions/wallet/sendTransaction",type:e==null?void 0:e.type})}catch(C){throw C instanceof P?C:W(C,{...a,account:e,chain:a.chain||void 0})}}const $="0x5792579257925792579257925792579257925792579257925792579257925792",H=I(0,{size:32});async function xt(t,a){const{account:o=t.account,capabilities:i,chain:d=t.chain,experimental_fallback:l,experimental_fallbackDelay:w=32,forceAtomic:c=!1,id:m,version:y="2.0.0"}=a,s=o?R(o):null,g=a.calls.map(f=>{const n=f,u=n.abi?it({abi:n.abi,functionName:n.functionName,args:n.args}):n.data;return{data:n.dataSuffix&&u?B([u,n.dataSuffix]):u,to:n.to,value:n.value?I(n.value):void 0}});try{const f=await t.request({method:"wallet_sendCalls",params:[{atomicRequired:c,calls:g,capabilities:i,chainId:I(d.id),from:s==null?void 0:s.address,id:m,version:y}]},{retryCount:0});return typeof f=="string"?{id:f}:f}catch(f){const n=f;if(l&&(n.name==="MethodNotFoundRpcError"||n.name==="MethodNotSupportedRpcError"||n.name==="UnknownRpcError"||n.details.toLowerCase().includes("does not exist / is not available")||n.details.toLowerCase().includes("missing or invalid. request()")||n.details.toLowerCase().includes("did not match any variant of untagged enum")||n.details.toLowerCase().includes("account upgraded to unsupported contract")||n.details.toLowerCase().includes("eip-7702 not supported")||n.details.toLowerCase().includes("unsupported wc_ method")||n.details.toLowerCase().includes("feature toggled misconfigured"))){if(i&&Object.values(i).some(p=>!p.optional)){const p="non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.";throw new ct(new N(p,{details:p}))}if(c&&g.length>1){const e="`forceAtomic` is not supported on fallback to `eth_sendTransaction`.";throw new ut(new N(e,{details:e}))}const u=[];for(const e of g){const p=Ct(t,{account:s,chain:d,data:e.data,to:e.to,value:e.value?A(e.value):void 0});u.push(p),w>0&&await new Promise(b=>setTimeout(b,w))}const h=await Promise.allSettled(u);if(h.every(e=>e.status==="rejected"))throw h[0].reason;const r=h.map(e=>e.status==="fulfilled"?e.value:H);return{id:B([...r,I(d.id,{size:32}),$])}}throw W(f,{...a,account:s,chain:a.chain})}}async function Tt(t,a){async function o(s){if(s.endsWith($.slice(2))){const f=lt(j(s,-64,-32)),n=j(s,0,-64).slice(2).match(/.{1,64}/g),u=await Promise.all(n.map(r=>H.slice(2)!==r?t.request({method:"eth_getTransactionReceipt",params:[`0x${r}`]},{dedupe:!0}):void 0)),h=u.some(r=>r===null)?100:u.every(r=>(r==null?void 0:r.status)==="0x1")?200:u.every(r=>(r==null?void 0:r.status)==="0x0")?500:600;return{atomic:!1,chainId:U(f),receipts:u.filter(Boolean),status:h,version:"2.0.0"}}return t.request({method:"wallet_getCallsStatus",params:[s]})}const{atomic:i=!1,chainId:d,receipts:l,version:w="2.0.0",...c}=await o(a.id),[m,y]=(()=>{const s=c.status;return s>=100&&s<200?["pending",s]:s>=200&&s<300?["success",s]:s>=300&&s<700?["failure",s]:s==="CONFIRMED"?["success",200]:s==="PENDING"?["pending",100]:[void 0,s]})();return{...c,atomic:i,chainId:d?U(d):void 0,receipts:(l==null?void 0:l.map(s=>({...s,blockNumber:A(s.blockNumber),gasUsed:A(s.gasUsed),status:dt[s.status]})))??[],statusCode:y,status:m,version:w}}async function It(t,a){var m;const{account:o=t.account,chainId:i,nonce:d}=a;if(!o)throw new D({docsPath:"/docs/eip7702/prepareAuthorization"});const l=R(o),w=(()=>{if(a.executor)return a.executor==="self"?a.executor:R(a.executor)})(),c={address:a.contractAddress??a.address,chainId:i,nonce:d};return typeof c.chainId>"u"&&(c.chainId=((m=t.chain)==null?void 0:m.id)??await E(t,G,"getChainId")({})),typeof c.nonce>"u"&&(c.nonce=await E(t,ht,"getTransactionCount")({address:l.address,blockTag:"pending"}),(w==="self"||w!=null&&w.address&&ft(w.address,l.address))&&(c.nonce+=1)),c}class vt extends N{constructor(a){super(`Call bundle failed with status: ${a.statusCode}`,{name:"BundleFailedError"}),Object.defineProperty(this,"result",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.result=a}}async function Rt(t,a){const{id:o,pollingInterval:i=t.pollingInterval,status:d=({statusCode:h})=>h===200||h>=300,retryCount:l=4,retryDelay:w=({count:h})=>~~(1<<h)*200,timeout:c=6e4,throwOnFailure:m=!1}=a,y=pt(["waitForCallsStatus",t.uid,o]),{promise:s,resolve:g,reject:f}=wt();let n;const u=mt(y,{resolve:g,reject:f},h=>{const r=gt(async()=>{const e=p=>{clearTimeout(n),r(),p(),u()};try{const p=await yt(async()=>{const b=await Tt(t,{id:o});if(m&&b.status==="failure")throw new vt(b);return b},{retryCount:l,delay:w});if(!d(p))return;e(()=>h.resolve(p))}catch(p){e(()=>h.reject(p))}},{interval:i,emitOnBegin:!0});return r});return n=c?setTimeout(()=>{u(),clearTimeout(n),f(new Et({id:o}))},c):void 0,await s}class Et extends N{constructor({id:a}){super(`Timed out while waiting for call bundle with id "${a}" to be confirmed.`,{name:"WaitForCallsStatusTimeoutError"})}}export{bt as a,xt as b,Tt as g,It as p,Ct as s,Rt as w};
