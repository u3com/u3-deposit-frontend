import{C as K,h as Q,j as V,U as X,T as Y,A as D,k as Z,r as tt,B as N,p as R,m as E,n as G,o as et,q as at,L as st,t as nt,u as rt,v as ot,w as P,x as it,y as I,b as B,z as ct,D as ut,E as A,F as U,G as dt,I as lt,J as j,i as ft,K as ht,s as pt,M as wt,N as mt,O as gt,P as yt}from"./index-Chhk3E_p.js";function bt({chain:e,currentChainId:a}){if(!e)throw new K;if(a!==e.id)throw new Q({chain:e,currentChainId:a})}function W(e,{docsPath:a,...o}){const i=(()=>{const u=V(e,o);return u instanceof X?e:u})();return new Y(i,{docsPath:a,...o})}const S=new st(128);async function Ct(e,a){var f,b,M,_;const{account:o=e.account,chain:i=e.chain,accessList:u,authorizationList:d,blobs:h,data:c,gas:m,gasPrice:g,maxFeePerBlobGas:l,maxFeePerGas:s,maxPriorityFeePerGas:p,nonce:n,type:w,value:r,...y}=a;if(typeof o>"u")throw new D({docsPath:"/docs/actions/wallet/sendTransaction"});const t=o?R(o):null;try{Z(a);const C=await(async()=>{if(a.to)return a.to;if(a.to!==null&&d&&d.length>0)return await tt({authorization:d[0]}).catch(()=>{throw new N("`to` is required. Could not infer from `authorizationList`.")})})();if((t==null?void 0:t.type)==="json-rpc"||t===null){let v;i!==null&&(v=await E(e,G,"getChainId")({}),bt({currentChainId:v,chain:i}));const x=(M=(b=(f=e.chain)==null?void 0:f.formatters)==null?void 0:b.transactionRequest)==null?void 0:M.format,k=(x||et)({...at(y,{format:x}),accessList:u,authorizationList:d,blobs:h,chainId:v,data:c,from:t==null?void 0:t.address,gas:m,gasPrice:g,maxFeePerBlobGas:l,maxFeePerGas:s,maxPriorityFeePerGas:p,nonce:n,to:C,type:w,value:r}),L=S.get(e.uid),J=L?"wallet_sendTransaction":"eth_sendTransaction";try{return await e.request({method:J,params:[k]},{retryCount:0})}catch(O){if(L===!1)throw O;const T=O;if(T.name==="InvalidInputRpcError"||T.name==="InvalidParamsRpcError"||T.name==="MethodNotFoundRpcError"||T.name==="MethodNotSupportedRpcError")return await e.request({method:"wallet_sendTransaction",params:[k]},{retryCount:0}).then(F=>(S.set(e.uid,!0),F)).catch(F=>{const q=F;throw q.name==="MethodNotFoundRpcError"||q.name==="MethodNotSupportedRpcError"?(S.set(e.uid,!1),T):q});throw T}}if((t==null?void 0:t.type)==="local"){const v=await E(e,nt,"prepareTransactionRequest")({account:t,accessList:u,authorizationList:d,blobs:h,chain:i,data:c,gas:m,gasPrice:g,maxFeePerBlobGas:l,maxFeePerGas:s,maxPriorityFeePerGas:p,nonce:n,nonceManager:t.nonceManager,parameters:[...rt,"sidecars"],type:w,value:r,...y,to:C}),x=(_=i==null?void 0:i.serializers)==null?void 0:_.transaction,z=await t.signTransaction(v,{serializer:x});return await E(e,ot,"sendRawTransaction")({serializedTransaction:z})}throw(t==null?void 0:t.type)==="smart"?new P({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new P({docsPath:"/docs/actions/wallet/sendTransaction",type:t==null?void 0:t.type})}catch(C){throw C instanceof P?C:W(C,{...a,account:t,chain:a.chain||void 0})}}const $="0x5792579257925792579257925792579257925792579257925792579257925792",H=I(0,{size:32});async function xt(e,a){const{account:o=e.account,capabilities:i,chain:u=e.chain,experimental_fallback:d,experimental_fallbackDelay:h=32,forceAtomic:c=!1,id:m,version:g="2.0.0"}=a,l=o?R(o):null,s=a.calls.map(p=>{const n=p,w=n.abi?it({abi:n.abi,functionName:n.functionName,args:n.args}):n.data;return{data:n.dataSuffix&&w?B([w,n.dataSuffix]):w,to:n.to,value:n.value?I(n.value):void 0}});try{const p=await e.request({method:"wallet_sendCalls",params:[{atomicRequired:c,calls:s,capabilities:i,chainId:I(u.id),from:l==null?void 0:l.address,id:m,version:g}]},{retryCount:0});return typeof p=="string"?{id:p}:p}catch(p){const n=p;if(d&&(n.name==="MethodNotFoundRpcError"||n.name==="MethodNotSupportedRpcError"||n.name==="UnknownRpcError"||n.details.toLowerCase().includes("does not exist / is not available")||n.details.toLowerCase().includes("missing or invalid. request()")||n.details.toLowerCase().includes("did not match any variant of untagged enum")||n.details.toLowerCase().includes("account upgraded to unsupported contract")||n.details.toLowerCase().includes("eip-7702 not supported")||n.details.toLowerCase().includes("unsupported wc_ method")||n.details.toLowerCase().includes("feature toggled misconfigured"))){if(i&&Object.values(i).some(f=>!f.optional)){const f="non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.";throw new ct(new N(f,{details:f}))}if(c&&s.length>1){const t="`forceAtomic` is not supported on fallback to `eth_sendTransaction`.";throw new ut(new N(t,{details:t}))}const w=[];for(const t of s){const f=Ct(e,{account:l,chain:u,data:t.data,to:t.to,value:t.value?A(t.value):void 0});w.push(f),h>0&&await new Promise(b=>setTimeout(b,h))}const r=await Promise.allSettled(w);if(r.every(t=>t.status==="rejected"))throw r[0].reason;const y=r.map(t=>t.status==="fulfilled"?t.value:H);return{id:B([...y,I(u.id,{size:32}),$])}}throw W(p,{...a,account:l,chain:a.chain})}}async function Tt(e,a){var l;async function o(s){if(s.endsWith($.slice(2))){const n=lt(j(s,-64,-32)),w=j(s,0,-64).slice(2).match(/.{1,64}/g),r=await Promise.all(w.map(t=>H.slice(2)!==t?e.request({method:"eth_getTransactionReceipt",params:["0x".concat(t)]},{dedupe:!0}):void 0)),y=r.some(t=>t===null)?100:r.every(t=>(t==null?void 0:t.status)==="0x1")?200:r.every(t=>(t==null?void 0:t.status)==="0x0")?500:600;return{atomic:!1,chainId:U(n),receipts:r.filter(Boolean),status:y,version:"2.0.0"}}return e.request({method:"wallet_getCallsStatus",params:[s]})}const{atomic:i=!1,chainId:u,receipts:d,version:h="2.0.0",...c}=await o(a.id),[m,g]=(()=>{const s=c.status;return s>=100&&s<200?["pending",s]:s>=200&&s<300?["success",s]:s>=300&&s<700?["failure",s]:s==="CONFIRMED"?["success",200]:s==="PENDING"?["pending",100]:[void 0,s]})();return{...c,atomic:i,chainId:u?U(u):void 0,receipts:(l=d==null?void 0:d.map(s=>({...s,blockNumber:A(s.blockNumber),gasUsed:A(s.gasUsed),status:dt[s.status]})))!=null?l:[],statusCode:g,status:m,version:h}}async function It(e,a){var m,g,l;const{account:o=e.account,chainId:i,nonce:u}=a;if(!o)throw new D({docsPath:"/docs/eip7702/prepareAuthorization"});const d=R(o),h=(()=>{if(a.executor)return a.executor==="self"?a.executor:R(a.executor)})(),c={address:(m=a.contractAddress)!=null?m:a.address,chainId:i,nonce:u};return typeof c.chainId>"u"&&(c.chainId=(l=(g=e.chain)==null?void 0:g.id)!=null?l:await E(e,G,"getChainId")({})),typeof c.nonce>"u"&&(c.nonce=await E(e,ht,"getTransactionCount")({address:d.address,blockTag:"pending"}),(h==="self"||h!=null&&h.address&&ft(h.address,d.address))&&(c.nonce+=1)),c}class vt extends N{constructor(a){super("Call bundle failed with status: ".concat(a.statusCode),{name:"BundleFailedError"}),Object.defineProperty(this,"result",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.result=a}}async function Rt(e,a){const{id:o,pollingInterval:i=e.pollingInterval,status:u=({statusCode:r})=>r===200||r>=300,retryCount:d=4,retryDelay:h=({count:r})=>~~(1<<r)*200,timeout:c=6e4,throwOnFailure:m=!1}=a,g=pt(["waitForCallsStatus",e.uid,o]),{promise:l,resolve:s,reject:p}=wt();let n;const w=mt(g,{resolve:s,reject:p},r=>{const y=gt(async()=>{const t=f=>{clearTimeout(n),y(),f(),w()};try{const f=await yt(async()=>{const b=await Tt(e,{id:o});if(m&&b.status==="failure")throw new vt(b);return b},{retryCount:d,delay:h});if(!u(f))return;t(()=>r.resolve(f))}catch(f){t(()=>r.reject(f))}},{interval:i,emitOnBegin:!0});return y});return n=c?setTimeout(()=>{w(),clearTimeout(n),p(new Et({id:o}))},c):void 0,await l}class Et extends N{constructor({id:a}){super('Timed out while waiting for call bundle with id "'.concat(a,'" to be confirmed.'),{name:"WaitForCallsStatusTimeoutError"})}}export{bt as a,xt as b,Tt as g,It as p,Ct as s,Rt as w};
